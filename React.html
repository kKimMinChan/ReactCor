<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script type="text/babel" src="./app.js"></script> -->
  <script type="text/babel">
    // console.log(React);
    // console.log(ReactDOM);


    //React는 실제로 DOM을 제어하는 방식이 아니라 중간에 가상의 DOM인 Virtual DOM을 두어 개발의 편의성(DOM을 직접 제어하지 않음)과 성능(배치 처리로 DOM 변경)을 개선했다.
    //Virtual DOM은 실제 DOM의 구조와 비슷한, React 객체의 트리다. 개발자는 직접 DOM을 제어하지 않고 Virtual DOM을 제어하고, React에서 적절하게 Virtual DOM을 DOM에 반영하는 작업을 한다. 
    
    // ReactDOM.render() 함수를 호출하면 Virtual DOM을 만들기 시작한다.
    // React 컴포넌트는 페이지에 렌더링할 React 엘리먼트를 반환하는 작고 재사용 가능한 코드 조각입니다. 가장 간단한 React 컴포넌트는 React 엘리먼트를 반환하는 일반 JavaScript 함수입니다.

    // class 컴포넌트
    // class ClassComponent extends React.Component {
    //   render() {
    //     return <div>Hello</div>;
    //   }
    // }
    // //사용
    // ReactDOM.render(<ClassComponent />, document.querySelector("#root"));

    //function 컴포넌트
    // function FunctionComponent() {
    //   return <div>Hello</div>
    // }
    // //사용
    // ReactDOM.render(<FunctionComponent />, document.querySelector("#root"));

    //function 컴포넌트 (화살표함수)
    // const FunctionComponent = () => <div>Hello</div>;
    // //사용
    // ReactDOM.render(<FunctionComponent />, document.querySelector("#root"));
    
    
    //리액트는React.createElement(type, [props], [...children]) 라는 API를 통해 컴포넌트를 생성한다. type 부분에는 React 엘리먼트 타입, HTML 태그 타입, React Fragment 타입 중 하나가 올 수 있다.

    // React.createElement(
    //   type // 태그 이름 문자열 | 리액트 컴포넌트 | React.Fragment
    //   [props] // 리액트 컴포넌트에 넣어주는 데이터 객체
    //   [...children] // 자식으로 넣어주는 요소들
    // );


    // 1. 태그 이름 문자열 type <h1>type 이 "태그 이름 문자열" 입니다.</h1>
    // ReactDOM.render(
    //   React.createElement('h1', null, `type 이 "태그 이름 문자열" 입니다.`),
    //   document.querySelector("#root")
    // )

    // 2. 리액트 컨포넌트 type
    // const Component = () => {
    //   return React.createElement('p', null, `type 이 "React 컴포넌트" 입니다.`);
    // };    
    // //<Component></Conponent> => <Component /> => <p></p>
    // ReactDOM.render(
    //   React.createElement(Component, null, null),
    //   document.querySelector("#root")
    // );

    // 3. React.Fragment
  //   ReactDOM.render(
  //     React.createElement(
  //     React.Fragment,
  //     null,
  //     `type 이 "React Fragment" 입니다.`,
  //     `type 이 "React Fragment" 입니다.`,
  //     `type 이 "React Fragment" 입니다.`
  //   ),
  //   document.querySelector("#root")
  // );

  // 4. 복잡한 리액트 엘리먼트 모임
  // <div>
  //   <div>
  //     <h1>주제</h1>
  //     <ul>
  //       <li>React</li>
  //       <li>Vue</li>
  //     </ul>
  //   </div>
  // </div>
  // ReactDOM.render(
  //   React.createElement(
  //     'div', 
  //     null, 
  //     React.createElement(
  //       'div', 
  //       null, 
  //       React.createElement('h1', null, "주제"),
  //       React.createElement(
  //         "ul", 
  //         null, 
  //         React.createElement("li", null, "React"),
  //         React.createElement("li", null, "Veu")
  //       )
  //     )
  //   ),
  //   document.querySelector("#root")
  // )
  
  // 우리가 작성한 어떤 코드 => 순수하게 실행할 수 있는 자바스크립트(JSX)
  //JSX 문법
  //최상위 요소가 하나여야 합니다.
  //최상위 요소 리턴하는 경우, ()로 감싸야 합니다.
  //자식들을 바로 랜더링하고 싶으면, <>자식들</>를 사용합니다. => Fragment
  //자바스크립트 표현식을 사용하려면, {표현식}를 이용합니다.
  //if 문은 사용할 수 없습니다. 삼항 연산자 혹은 &&를 사용합니다.
  //style을 이용해 인라인 스타일링이 가능합니다.
  //class 대신 className을 사용해 class를 적용할 수 있습니다.
  //자식요소가 있으면, 꼭 닫아야 하고, 자식요소가 없으면 열면서 닫아야 합니다.
  // babel 
    // const title = "주제"
    // ReactDOM.render(
    //   <>
    //     <div>
    //       <div>
    //         <h1>{title}</h1>
    //         <ul>
    //           <li>React</li>
    //           <li>Vue</li>
    //           <>sdf</>
    //         </ul>
    //       </div>
    //     </div>
    //     <div>
    //       <div>
    //         <h1>주제</h1>
    //         <ul>
    //           <li>React</li>
    //           <li>Vue</li>
    //           <>sdf</>
    //         </ul>
    //       </div>
    //     </div>
    //   </>,
    //   document.querySelector("#root")
    // );


    // Props는 컴포넌트 외부에서 컴포넌트에게 주는 데이터입니다.
    // State는 컴포넌트 내부에서 변경할 수 있는 데이터입니다.
    // 둘 다 변경이 발생하면, 랜더가 다시 일어날 수 있습니다.

    //함수 컨포넌트 사용
    // function Component(props) {
    //   return <div><h1>{props.message} 이것은 함수로 만든 컴포넌트 입니다.</h1></div>;
    // }
    // ReactDOM.render(
    //   <Component message="안녕하세요"/>,
    //   document.querySelector("#root")
    // );

    // class 컴포넌트 사용
    // class Component extends React.Component {
    //   render() {
    //     return (
    //       <div>
    //         <h1>
    //           {this.props.message} 이것은 클래스로 만든 컴포넌트 입니다.
    //         </h1>
    //       </div>
    //     )
    //   }
    // }
    // ReactDOM.render(
    //   <Component message="안녕하세요!!!" />,
    //   document.querySelector("#root")
    // );


    // class props 기본값 주기
    // class Component extends React.Component {
    //   render() {
    //     return (
    //       <div>
    //         <h1>
    //           {this.props.message} 이것은 클래스로 만든 컴포넌트 입니다.
    //         </h1>
    //       </div>
    //     )
    //   }
    //   //방법 1 클래스에서만 사용가능
    //   // static defaultProps = {
    //   //   message: "기본값1",
    //   // };
    // }
    // //방법2 함수에서도 사용 가능
    // Component.defaultProps = {
    //   message: "기본값2",
    // }
    // ReactDOM.render(
    //   <Component />,
    //   document.querySelector("#root")
    // );


    // class 에서 state 사용 state 변경 규칙 
    // class Component extends React.Component {
    //   // state 방식1 항상 객체이여야 함
    //   // state = {
    //   //   count: 0,
    //   // };
    //   // state 생성 방식2 
    //   constructor(props) {
    //     super(props)
    //     this.state = { count: 0 };
    //   }
    //   render() {
    //     return (
    //       <p>{this.state.count}</p>
    //     );
    //   }
    //   //state 변경하기
    //   componentDidMount() {
    //     setTimeout(() => {
    //       // this.state.count = this.state.count + 1;
    //       //방식 1 this.setState에서 새로운 state 객체를 넣어야 됨(state값을 바꾸려면)
    //       // this.setState({
    //       //   count: this.state.count + 1,
    //       // });

    //       //방식 2
    //       this.setState((previousState) => {
    //         const newState = { count: previousState.count + 1 }
    //         return newState;
    //       });
    //     }, 1000);
    //   }

    // }
    // ReactDOM.render(
    //   <Component />,
    //   document.querySelector("#root")
    // );


    // Event Handing

    // camelCase 로만 사용할 수 있습니다.
    //   onClick, onMouseEnter
    // 이벤트에 연결된 자바스크립트 코드는 함수입니다.
    //   이벤트={함수} 와 같이 씁니다.
    // 실제 DOM 요소들에만 사용 가능합니다.
    //   리액트 컴포넌트에 사용하면, 그냥 props 로 전달합니다.

    // function Component() {
    //   return <div>
    //     <button 
    //       onClick={() => {
    //         console.log("clicked");
    //       }}>
    //         클릭
    //     </button>
    //   </div>
    // }
//여기서 부터 시작~~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // const Component = () => 
    //   <div>
    //     <button onClick = {() => {
    //       console.log("clicked");
    //         }}>
    //           클릭
    //     </button>
    //   </div>;
    // ReactDOM.render(<Component />, document.querySelector("#root"));

    // class Component extends React.Component {
    //   state = {
    //     count : 0,
    //   };
    //   // render() {
    //   //   return(
    //   //     <div>
    //   //       <p>{this.state.count}</p>
    //   //       <button 
    //   //         onClick={() => {
    //   //           console.log("clicked");
    //   //           // ...은 복사
    //   //           this.setState((state) => ({...state, count: state.count + 1, }));
    //   //         }}>
    //   //           클릭
    //   //       </button>
    //   //     </div>
    //   //   );
    //   // }

    //   render() {
    //     return(
    //       <div>
    //         <p>{this.state.count}</p>
    //         <button onClick={this.click}>클릭</button>
    //       </div>
    //     );
    //   }
    //   click = () => {
    //     console.log("clicked");
    //     // ...은 복사
    //     this.setState((state) => ({
    //       ...state, 
    //       count: state.count + 1,
    //     }));
    //   };
    // }
    // ReactDOM.render(<Component />, document.querySelector("#root"));

    // class App extends React.Component {
    //   state = {
    //     age: 39,
    //   };
    //   interval = null
    //   constructor(props) {
    //     super(props);

    //     console.log("constructor", props);
    //   }
    //   render() {
    //     console.log('render');
    //     return (
    //       <div>
    //         <h2>
    //           Hello {this.props.name} - {this.state.age}
    //         </h2>
    //       </div>
    //     );
    //   }
    //   componentWillMount() {
    //     console.log("componentWillMount");
    //   }
    //   componentDidMount() {
    //     console.log("componentDidMount");
    //     this.interval = setInterval(() => {
    //       //console.log("setInterval");
    //       this.setState(state => ({ ...state, age: state.age + 1}))
    //     }, 1000);
    //   }
    //   componentWillReceiveProps(nextProps) {
    //     console.log("componentWillReceiveProps", nextProps);
    //     //props 를 새로 지정했을 때 바로 호출됩니다.
    //     //여기는 state의 변경에 반응하지 않습니다.
    //     //여기서 props 의 값에 따라 state 를 변경해야 한다면,
    //     //setState 를 이용해 state 를 변경합니다.
    //     //그러면 다음 이벤트로 각각 가는것이 아니라 한번에 변경됩니다.
    //   }
    //   shouldComponentUpdate(nextProps, nextState)  {
    //     console.log("shouldComponentUpdate", nextProps, nextState);
    //     // props만 변경되어도, state만 변경되어도, props & state 모두 변경되어도
    //     //newProps 와 new State 를 인자로 해서 호출
    //     // return type이 boolean입니다.
    //     //true면 render false면 render 가 호출되지 않습니다. 이 함수를 구현하지 않으면, 디폴트는 true
    //     return true
    //   }
    //   componentWillUpdate(nextProps, nextState) {
    //     console.log("componentWillUpdate", nextProps, nextState);
    //     //컴포넌트가 재 랜더링 되기 직전에 불립니다.
    //     //여기선 setState 같은 것을 쓰면 안됩니다.
    //   }
    //   componentDidUpdate(prevProps, prevState) {
    //     console.log("componentDidUpdate", prevProps, prevState);
    //     //컴포넌트가 재 랜더링을 마치면 불립니다.
    //   }

    //   componentWillUnmount() {
    //     clearInterval(this.interval);
    //   }
    // }
    // ReactDOM.render(<App name="Mark" />, document.querySelector("#root"));


    // Component props, state 변경(< v16.3) 순서 ! state는 shouldComponentUpdate 여기부터 시작
    // componentWillReceiveprops
    // shouldComponentUpdate
    // componentWillUpdate
    // render
    // componentDidUpdate

    //Component 라이프사이클 변경 (v16.3)
    //constructor
    //componentWillMount => getDerivedStateFromProps
    //render
    //componentDidMount
    // componentWillReceiveProps => getDerivedStateFromProps
    // shouldComponentUpdate
    // render
    // componentWillUpdate => getSnapshotBeforeUpdate
    // (dom 에  적용)
    // componentDidUpdate
    // componentWillUnmount

    // class App extends React.Component {
    //   state = {
    //     age: 39,
    //   };
    //   interval = null
    //   constructor(props) {
    //     super(props);

    //     console.log("constructor", props);
    //   }
    //   render() {
    //     console.log('render');
    //     return (
    //       <div>
    //         <h2>
    //           Hello {this.props.name} - {this.state.age}
    //         </h2>
    //       </div>
    //     );
    //   }
    //   // static getDerivedStateFromProps(nextProps, prevState) {
    //   //   console.log("getDerivedStateFromProps", nextProps, prevState);
    //   //   return {
    //   //     age: 390,
    //   //   };
    //   // }
    //   componentDidMount() {
    //     console.log("componentDidMount");
    //     this.interval = setInterval(() => {
    //       //console.log("setInterval");
    //       this.setState(state => ({ ...state, age: state.age + 1}))
    //     }, 1000);
    //   }
    //   // componentWillReceiveProps(nextProps) {
    //   //   console.log("componentWillReceiveProps", nextProps);
    //   // }
    //   shouldComponentUpdate(nextProps, nextState)  {
    //     console.log("shouldComponentUpdate", nextProps, nextState);
    //     return true
    //   }
    //   // componentWillUpdate(nextProps, nextState) {
    //   //   console.log("componentWillUpdate", nextProps, nextState);
    //   // }
    //   componentDidUpdate(prevProps, prevState) {
    //     console.log("componentDidUpdate", prevProps, prevState);
    //   }

    //   componentWillUnmount() {
    //     clearInterval(this.interval);
    //   }
    // }
    
    //ReactDOM.render(<App name="Mark" />, document.querySelector("#root"));

    // let i = 0;
    // class App extends React.Component {
    //   state = {list: []};

    //   render() {
    //     return (
    //       <div id="list" style={{height: 100, overflow: "scroll"}}>
    //         {this.state.list.map((i) => {
    //           return <div>{i}</div>;
    //         })}
    //       </div>
    //     );
    //   }

    //   componentDidMount() {
    //     setInterval(() => {
    //       this.setState((state) => ({
    //         list: [...state.list, i++],
    //       }));
    //     }, 1000);
    //   }

    //   getSnapshotBeforeUpdate(prevProps, prevState) {
    //     if (prevState.list.length === this.state.list.length) return null;
    //     const list = document.querySelector("#list");
    //     return list.scrollHeight - list.scrollTop;
    //   }
    //   componentDidUpdate(prevProps, prevState, snapshot) {
    //     console.log(snapshot);
    //     if (snapshot === null) return;
    //     const list = document.querySelector("#list");
    //     list.scrollTop = list.scrollHeight - snapshot;
    //   }
    // }
    
    // ReactDOM.render(<App name="Mark" />, document.querySelector("#root"));

    // class App extends React.Component {
    //   state = {
    //     hasError: false
    //   }
    //   render() {
    //     if (this.state.hasError) {
    //       return <div>예상치 못한 에러가 발생했다.</div>;
    //     }
    //     return <WebService />;
    //   }
    //   componentDidCatch(error, info) {
    //     this.setState({ hasError: true });
    //   }
    // }
    // ReactDOM.render(<App name="Mark" />, document.querySelector("#root"));

  </script>

</body>

</html>